<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>PERFORMANCE TESTING</title>
        <link rel="stylesheet" href="performance.css">
    </head>
    <body>
        <div class="main">
            <div class="performance">
                <h1>PERFORMANCE TESTING</h1>
            </div>
            <p><b>Performance Testing</b> is a software testing process used for testing the speed, response time, stability, reliability, scalability, and resource usage of a software application under a particular workload. The main purpose of performance testing is to identify and eliminate the performance bottlenecks in the software application. It is a subset of performance engineering and is also known as <b>“Perf Testing”</b>.</p>
            <br>
            <p>The focus of Performance Testing is checking a software program’s</p>
            <ul>
                <li><b>Speed</b> – Determines whether the application responds quickly</li>
                <li><b>Scalability</b> – Determines the maximum user load the software application can handle.</li>
                <li><b>Stability</b> – Determines if the application is stable under varying loads</li>
            </ul>
            <h2>Types of Performance Testing</h2>
            <ul>
                <li><b>Load testing</b> – checks the application’s ability to perform under anticipated user loads. The objective is to identify performance bottlenecks before the software application goes live.</li>
                <li><b>Stress testing</b> – involves testing an application under extreme workloads to see how it handles high traffic or data processing. The objective is to identify the breaking point of an application.</li>
                <li><b>Endurance testing</b> – is done to make sure the software can handle the expected load over a long period of time.</li>
                <li><b>Spike testing</b> – tests the software’s reaction to sudden large spikes in the load generated by users.</li>
                <li><b>Volume testing</b> – Under Volume Testing large no. of. Data is populated in a database, and the overall software system’s behavior is monitored. The objective is to check software application’s performance under varying database volumes.</li>
                <li><b>Scalability testing</b> – The objective of scalability testing is to determine the software application’s effectiveness in “scaling up” to support an increase in user load. It helps plan capacity addition to your software system.</li>
            </ul>
            <h2>Common Performance Problems</h2>
            <p>Most performance problems revolve around speed, response time, load time, and poor scalability. Speed is often one of the most important attributes of an application. A slow-running application will lose potential users. Performance testing ensures an app runs fast enough to keep a user’s attention and interest. Take a look at the following list of common performance problems and notice how speed is a common factor in many of them:</p>
            <ul>
                <li><b>Long Load time</b> – Load time is normally the initial time it takes an application to start. This should generally be kept to a minimum. While some applications are impossible to make load in under a minute, Load time should be kept under a few seconds if possible.</li>
                <li><b>Poor response time</b> – Response time is the time it takes from when a user inputs data into the application until the application outputs a response to that input. Generally, this should be very quick. Again if a user has to wait too long, they lose interest.</li>
                <li><b>Poor scalability</b> – A software product suffers from poor scalability when it cannot handle the expected number of users or when it does not accommodate a wide enough range of users. Load Testing should be done to be certain the application can handle the anticipated number of users.</li>
                <li><b>Bottlenecking</b> – Bottlenecks are obstructions in a system that degrade overall system performance. Bottlenecking is when either coding errors or hardware issues cause a decrease in throughput under certain loads. Bottlenecking is often caused by one faulty section of code. The key to fixing a bottlenecking issue is finding the section of code causing the slow down and trying to fix it there. Bottlenecking is generally fixed by either fixing poor running processes or adding additional Hardware. Some <b>common performance bottlenecks</b> are
                <ul>
                    <li>CPU utilization</li>
                    <li>Memory utilization</li>
                    <li>Network utilization</li>
                    <li>Operating System limitations</li>
                    <li>Disk usage</li>
                </ul>
                </li>
            </ul>
            <h2>Performance Testing Metrics: Parameters Monitored</h2>
            <p>The basic parameters monitored during performance testing include:</p>
            <img src="https://www.guru99.com/images/performancetestingparameters.png">
            <ul>
                <li><b>Processor Usage</b> – an amount of time processor spends executing non-idle threads.</li>
                <li><b>Memory use</b> – amount of physical memory available to processes on a computer.</li>
                <li><b>Disk time</b> – amount of time disk is busy executing a read or write request.</li>
                <li><b>Bandwidth</b> – shows the bits per second used by a network interface.</li>
                <li><b>Private bytes</b> – number of bytes a process has allocated that can’t be shared amongst other processes. These are used to measure memory leaks and usage.</li>
                <li><b>Committed memory</b> – amount of virtual memory used.</li>
                <li><b>Memory pages/second</b> – number of pages written to or read from the disk in order to resolve hard page faults. Hard page faults are when code not from the current working set is called up from elsewhere and retrieved from a disk.</li>
                <li><b>Page faults/second</b> – the overall rate in which fault pages are processed by the processor. This again occurs when a process requires code from outside its working set.</li>
                <li><b>CPU interrupts per second</b> – is the avg. number of hardware interrupts a processor is receiving and processing each second.</li>
                <li><b>Disk queue length</b> – is the avg. no. of read and write requests queued for the selected disk during a sample interval.</li>
                <li><b>Network output queue length</b> – length of the output packet queue in packets. Anything more than two means a delay and bottlenecking needs to be stopped.</li>
                <li><b>Network bytes total per second</b> – rate which bytes are sent and received on the interface including framing characters.</li>
                <li><b>Response time</b> – time from when a user enters a request until the first character of the response is received.</li>
                <li><b>Throughput</b> – rate a computer or network receives requests per second.</li>
                <li><b>Amount of connection pooling</b> – the number of user requests that are met by pooled connections. The more requests met by connections in the pool, the better the performance will be.</li>
                <li><b>Maximum active sessions</b> – the maximum number of sessions that can be active at once.</li>
                <li><b>Hit ratios</b> – This has to do with the number of SQL statements that are handled by cached data instead of expensive I/O operations. This is a good place to start for solving bottlenecking issues.</li>
                <li><b>Hits per second</b> – the no. of hits on a web server during each second of a load test.</li>
                <li><b>Rollback segment</b> – the amount of data that can rollback at any point in time.</li>
                <li><b>Database locks</b> – locking of tables and databases needs to be monitored and carefully tuned.</li>
                <li><b>Top waits</b> – are monitored to determine what wait times can be cut down when dealing with the how fast data is retrieved from memory</li>
                <li><b>Thread counts</b> – An applications health can be measured by the no. of threads that are running and currently active.</li>
                <li><b>Garbage collection</b> – It has to do with returning unused memory back to the system. Garbage collection needs to be monitored for efficiency.</li>
            </ul>
            <br>
        </div>
    </body>
</html>